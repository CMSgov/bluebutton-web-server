services:
  ####################
  # Postgres database
  # Pin to the version of Postgres that is 
  # equivalent to production.
  db:
    image: postgres:16
    env_file:
      - .env.local
    ports:
      - "5432:5432"
  ####################
  # Local MSLS server
  # A small Flask app for testing.
  msls:
    image: msls-local:latest
    platform: linux/amd64
    command: /code/start-local.sh
    ports:
      - "8080:8080"
    volumes:
      - ../msls-local:/code
  ####################
  # Blue Button
  web:
    image: bb-local:latest
    platform: linux/amd64
    command: /code/dev-local/start-local.sh
    read_only: true
    env_file:
      - .env.container
    volumes:
      # Comment out the /code bind to simulate
      # a completely read-only container, with statically
      # built CSS assets inside the image.
      - type: bind
        source: ..
        target: /code
        read_only: true
      - type: bind
        source: ~/.bb2/certstore
        target: /certstore
        read_only: true
      # We are simulating a writeable space at /media.
      # As we move to containerized production, we need to
      # remove this, and instead have all writes go to a
      # mocked S3 endpoint.
      # See also 
      # https://stackoverflow.com/questions/53498380/docker-compose-mounting-a-tmpfs-usable-by-non-root-user
      - type: tmpfs
        target: /media
        tmpfs:
          size: 64m
          mode: 777
    ports:
      - "8000:8000"
      - "5678:5678"
    depends_on:
      - db
      - msls


  # s3mock:
  #   image: adobe/s3mock:latest
  #   environment:
  #     - debug=true
  #     - COM_ADOBE_TESTING_S3MOCK_STORE_INITIAL_BUCKETS=mediabucket
  #     - COM_ADOBE_TESTING_S3MOCK_STORE_RETAIN_FILES_ON_EXIT=true
  #     - COM_ADOBE_TESTING_S3MOCK_STORE_ROOT=containers3root
  #   volumes:
  #     - ./locals3root:/container3root
  #   ports:
  #     - 9090:9090